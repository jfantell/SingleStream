"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var events = require("events"),
    EventEmitter = events.EventEmitter,
    express = require("express"),
    bodyParser = require("body-parser"),
    ul = require("ul"),
    http = require("http"),
    https = require("https"),
    fs = require("fs"),
    path = require("path"),
    toBuffer = require("./to-buffer"),
    session = require("express-session"),
    findValue = require("find-value"),
    connectMongo = require("connect-mongo"),
    qs = require("querystring"),
    parseUrl = require("parse-url"),
    Transformer = require("transformer"),
    setOrGet = require("set-or-get"),
    httpMethods = require("methods"),
    pathToRegexp = require("path-to-regexp"),
    iterateObject = require("iterate-object"),
    noop = require("noop6"),
    cookieParser = require("cookie-parser");

var LienObj = function () {

    /**
     * LienCreator
     * Creates the `lien` object.
     *
     * @name LienCreator
     * @function
     * @param {Object} req The request object.
     * @param {Object} res The response object.
     * @param {Function} next The `next` middleware function.
     * @param {Object} server The `Lien` server instance.
     * @return {Lien} The lien object.
     */
    function LienObj(req, res, next, server) {
        _classCallCheck(this, LienObj);

        this._next = next;
        this.req = req;
        this.res = res;

        this.url = parseUrl(req.originalUrl);
        this.path = this.req.path;

        if (this.path.charAt(this.path.length - 1) === "/") {
            this.path = this.path.slice(0, -1) || "/";
        }

        this.host = req.hostname;
        this.params = req.params;
        this.query = req.query;
        this.pathname = this.url.pathname;
        this.method = req.method.toLowerCase();
        this.cookies = req.cookies || {};
        this.server = server;
        this.data = req.body;
        this.session = req.session;

        this.full_path = req.originalUrl;
        this.protocol = req.protocol;
        this.domain = this.protocol + "://" + this.host;
        this.href = "" + this.domain + req.originalUrl;
    }

    /**
     * next
     * Go to the next middleware handler.
     *
     * @name next
     * @function
     * @returns {Lien} The `Lien` instance.
     */


    _createClass(LienObj, [{
        key: "next",
        value: function next(err, data) {
            this._next(err, data);
            return this;
        }

        /**
         * redirect
         * Redirects the client to another url.
         *
         * @name redirect
         * @function
         * @param {String} newUrl The new url to redirect to.
         * @param {Boolean|Object} query If `true`, the request querystring parameters will be appended. If it's an object, it will be merged with the request querystring parameters.
         */

    }, {
        key: "redirect",
        value: function redirect(newUrl, query) {
            if (query) {
                var sQuery = null;
                sQuery = qs.stringify(query === true ? this.query : ul.merge(query, this.query));
                sQuery && (newUrl += "?" + sQuery);
            }
            this.res.redirect(newUrl);
        }

        /**
         * render
         * Renders a template to the client.
         *
         * @name render
         * @function
         * @param {String} template The template name.
         * @param {Object} data The template data.
         */

    }, {
        key: "render",
        value: function render(template, data) {
            this.res.render(template, data);
        }

        /*!
         * _checkSessionSupport
         * Checks if the session is supported or not.
         *
         * @name _checkSessionSupport
         * @function
         * @returns {Boolean} `false` if session is *not* supported. `true` otherwise.
         */

    }, {
        key: "_checkSessionSupport",
        value: function _checkSessionSupport() {
            if (this.session) {
                return true;
            }
            console.warn("You're trying to use a session feature, but you didn't enable the session support.");
            return false;
        }

        /**
         * startSession
         * Starts a session.
         *
         * @name startSession
         * @function
         * @param {Object} data The session data.
         */

    }, {
        key: "startSession",
        value: function startSession(data) {
            if (!this._checkSessionSupport()) {
                return;
            }
            this.setSessionData(data);
        }

        /**
         * setSessionData
         * Sets the session data.
         *
         * @name setSessionData
         * @function
         * @param {Object} data The session data.
         */

    }, {
        key: "setSessionData",
        value: function setSessionData(data) {
            if (!this._checkSessionSupport()) {
                return;
            }
            this.session._sessionData = ul.merge(data, this.getSessionData());
        }

        /**
         * getSessionData
         * Returns the session data object/specific field.
         *
         * @name getSessionData
         * @function
         * @param {Field} field A specific field to get from the session object.
         * @returns {Value|Object} The field value. If a field is not specified,
         * the whole session data object is returned.
         */

    }, {
        key: "getSessionData",
        value: function getSessionData(field) {
            if (!this._checkSessionSupport()) {
                return;
            }
            if (field) {
                return findValue(this.session._sessionData, field);
            }
            return this.session._sessionData;
        }

        /**
         * destroySession
         * Destroys the session.
         *
         * @name destroySession
         * @function
         */

    }, {
        key: "destroySession",
        value: function destroySession() {
            if (!this._checkSessionSupport()) {
                return;
            }
            this.session.destroy();
        }

        /**
         * header
         * Gets/sets/deletes headers.
         *
         * @name header
         * @function
         * @param {String} name The header name.
         * @param {String} value The header value to set. If `null`, the header will be *removed*.
         * @returns {Lien} The Lien instance.
         */

    }, {
        key: "header",
        value: function header(name, value) {
            var _this = this;

            if (!name && !value) {
                return this.req.headers;
            }

            if (value === null) {
                return this.res.removeHeader(name);
            }

            if (value === undefined && typeof name === "string") {
                return this.req.header(name);
            }

            if ((typeof name === "undefined" ? "undefined" : _typeof(name)) === "object") {
                iterateObject(name, function (value, name) {
                    return _this.header(name, value);
                });
                return this;
            }

            this.res.set(name, value);
            return this;
        }

        /**
         * apiMsg
         * Sends to the client a JSON object containing the `message` field.
         *
         * @name apiMsg
         * @function
         * @param {String} msg The API message.
         * @param {Number} status The status code (default: `200`).
         */

    }, {
        key: "apiMsg",
        value: function apiMsg(msg, status) {
            status = status || 200;
            this.end({ message: msg }, status);
        }

        /**
         * apiError
         * Like `apiMsg`, but by default with a status code of `422`.
         *
         * @name apiError
         * @function
         * @param {String} msg The API message.
         * @param {Number} status The status code (default: `422`).
         */

    }, {
        key: "apiError",
        value: function apiError(msg, status) {
            this.apiMsg(msg, status || 422);
        }

        /**
         * end
         * Ends the response sending the content.
         *
         * @name end
         * @function
         * @param {Anything} content The content that should be sent to the response.
         * @param {Number} status The status code.
         * @param {String} contentType The content type (e.g. `"json"`).
         * @param {Object} headers Additional headers to send in the response.
         */

    }, {
        key: "end",
        value: function end(content, status, contentType, headers) {
            var _this2 = this;

            var resData = {};

            // end(content, status, headers)
            if ((typeof contentType === "undefined" ? "undefined" : _typeof(contentType)) === "object") {
                headers = contentType;
                contentType = null;
            }

            // end(status, headers)
            if (typeof content === "number") {
                status = content;
                content = "";
            }

            resData.content = content;
            resData.status = status || 200;
            resData.headers = headers || {};
            resData.contentType = contentType;
            resData.lien = resData;

            var trans = this.server.getHooks("after", this.path, this.method);

            if (trans) {
                trans.start(resData, function (err, data) {
                    if (err) {
                        data.content = err;
                    }
                    _this2._sendResponse(data);
                });
            } else {
                this._sendResponse(resData);
            }
        }

        /*!
         * _sendResponse
         * Low level function for sending the response.
         *
         * @name _sendResponse
         * @function
         * @param {Object} resData An object containing the following fields:
         *
         *  - `content` (Anything): The data to send to client.
         *  - `status` (Number): The response status.
         *  - `headers` (Object): The headers object.
         *  - `contentType` (String): The content type.
         *
         */

    }, {
        key: "_sendResponse",
        value: function _sendResponse(resData) {

            if (this.res.headersSent) {
                return;
            }

            if (resData.content && resData.content.statusCode) {
                resData.status = resData.content.statusCode;
            }

            var bRes = toBuffer(resData.content);

            this.res.status(resData.status);
            this.header(resData.headers);

            this.res.type(resData.contentType || bRes.contentType);
            this.res.end(bRes.buffer);
        }

        /**
         * cookie
         * Sets, gets or deletes the cookie.
         *
         * @name cookie
         * @function
         * @param {String} cookie The searched cookie.
         * @param {String} value If provided and it not `null`, the cookie will be set. If it's null, the cookie will be deleted. If `value` is not provided, the cookie value will be returned.
         * @return {String|null|undefined} `null`, if the cookie was deleted. `undefined` if the cookie doesn't exist. The cookie value if this exists.
         */

    }, {
        key: "cookie",
        value: function cookie(name, value, options) {
            if (value === undefined) {
                return this.cookies[name];
            }

            if (value === null) {
                this.res.clearCookie(name);
            } else {
                this.res.cookie(name, value, options);
            }

            return this;
        }

        /**
         * file
         * Serves a file to the response.
         *
         * @name file
         * @function
         * @param {String} path Relative path to the file.
         * @param {String} customRoot Absolute path to the root directory (optional).
         */

    }, {
        key: "file",
        value: function file(filePath, customRoot) {
            if (!customRoot) {
                customRoot = this.server.options.public[0][1];
            }
            filePath = path.join(customRoot, filePath);
            this.res.sendFile(filePath);
        }
    }]);

    return LienObj;
}();

/**
 * Lien
 * Creates a new Lien instance.
 *
 * It extends the `EventEmitter` class.
 *
 * It emits the following events:
 *
 *  - `load` (err): After the server is started. If there are no errors, the `err` will be null.
 *  - `serverError` (err, req, res): The server unexpected error.
 *
 * @name Lien
 * @function
 * @param {Object} opt_options An object containing the following properties:
 *
 *  - `host` (String): The server host.
 *  - `port` (Integer): The server port.
 *  - `session` (Boolean|Object): Enable the session support. If it's an object, it will be merged with the following defaults and passed to [`express-session`](https://github.com/expressjs/session):
 *    - `secret` (String): This is the secret used to sign the session ID cookie (default: "lien server").
 *    - `resave` (Boolean): Forces the session to be saved back to the session store, even if the session was never modified during the request (default: false).
 *    - `saveUninitialized` (Boolean): Forces a session that is "uninitialized" to be saved to the store (default: `true`).
 *    - `cookie` (Object): The cookie [options](https://github.com/expressjs/cookie-parser).
 *    - `storeOptions` (Object): The [MongoStore options](https://github.com/kcbanner/connect-mongo).
 *    - `store`: (Object): A custom store object (optional, as long `storeOptions` is provided).
 *  - `public` (String|Array): The path to the public directory or an array of arrays in this format: `["/url/of/static/dir", "path/to/static/dir"]`.
 *
 *    Example:
 *
 *    ```js
 *    [
 *      ["/images", "path/to/images"]
 *    , ["/", "path/to/public"]
 *    ]
 *    ```
 *
 *  - `ssl` (Object): An object containing the following fields:
 *      - `key` (String): The path to the key file.
 *      - `cert` (String): The path to the cert file.
 *      - `_key` (String|Buffer): The key file content (defaults to the key file content).
 *      - `_cert` (String|Buffer): The cert file content (defaults to the cert file content).
 *
 *  - `views`
 *    - `path` (String): The path to the views directory.
 *    - `name` (String): The view engine name.
 *
 *  - `errorPages` (Object):
 *    - `notFound` (String|Function): The path to a custom 404 page or a function receiving the lien object as parameter. This can be used to serve custom 404 pages.
 *    - `serverError` (String|Function): The path to a custom 500 page or a function receiving the lien object as parameter. This can be used to serve custom 500 pages.
 *
 *  - `logErrors` (Boolean): Log the server errors (default: `true`).
 *
 * @return {Object} The Lien instance.
 */


module.exports = function (_EventEmitter) {
    _inherits(Lien, _EventEmitter);

    function Lien(options) {
        _classCallCheck(this, Lien);

        var _this3 = _possibleConstructorReturn(this, (Lien.__proto__ || Object.getPrototypeOf(Lien)).call(this));

        options = ul.merge(options, {
            public: [],
            session: false,
            errorPages: {},
            logErrors: true
        });

        _this3.express = express;
        _this3.router = express.Router();
        _this3.beforeRequest = express.Router();

        _this3.transformers = {
            before: {},
            after: {}
        };

        var app = _this3.app = express();

        if (options.views) {
            app.set("views", options.views.path);
            app.set("view engine", options.views.name);
        }

        app.use(bodyParser.json());
        app.use(bodyParser.urlencoded({ extended: true }));

        if (options.cookies) {
            app.use(cookieParser(options.cookie));
        }

        _this3.MongoStore = connectMongo(session);

        if (options.session) {
            options.session = ul.merge(options.session, {
                secret: "lien server",
                resave: false,
                saveUninitialized: true,
                cookie: {},
                store: null,
                storeOptions: {}
            });

            if (!options.session.store && options.session.storeOptions) {
                options.session.store = new _this3.MongoStore(options.session.storeOptions);
            }

            delete options.storeOptions;

            _this3.app.use(session(options.session));
        }

        // Handle ssl
        if (options.ssl) {
            options.ssl._key = options.ssl._key || fs.readFileSync(options.ssl.key);
            options.ssl._cert = options.ssl._cert || fs.readFileSync(options.ssl.cert);
            _this3.server = https.createServer({
                key: options.ssl._key,
                cert: options.ssl._cert
            }, _this3.app);
        } else {
            _this3.server = http.createServer(_this3.app);
        }

        if (!Array.isArray(options.public)) {
            options.public = [["/", options.public]];
        }

        _this3.options = options;

        app.use(_this3.beforeRequest);
        app.use(_this3.router);

        // Public directorie
        options.public.forEach(function (c) {
            _this3.addStaticPath(c[0], c[1]);
        });

        // Start listening on host:port
        _this3.server.listen(options.port, options.host, function (err) {
            _this3.emit("load", err);
        });

        if (options.errorPages) {
            process.nextTick(function () {
                _this3.errorPages(options.errorPages);
            });
        }
        return _this3;
    }

    _createClass(Lien, [{
        key: "addStaticPath",
        value: function addStaticPath(url, localPath) {
            this.app.use(url, express.static(localPath));
        }

        /*!
         * _handleRoute
         * Calls a function or serves a static file.
         *
         * @name _handleRoute
         * @function
         * @param {Request} req The request object.
         * @param {Response} res The response object.
         * @param {String|Function} output The path to a public file or a function.
         * @param {Array} args An array of custom arguments to be used in the function call.
         */

    }, {
        key: "_handleRoute",
        value: function _handleRoute(req, res, output, args, next) {
            var lien = new LienObj(req, res, next || noop, this);

            if (typeof output === "string") {
                return lien.file(output);
            }

            if (Array.isArray(args)) {
                args.unshift(lien);
            } else {
                args = [lien];
            }

            output.apply(this, args);
        }

        /*!
         * _handleLienRoute
         *
         * @name _handleLienRoute
         * @function
         * @param {Lien} lien The Lien instance.
         * @param {Function} output The route handler.
         */

    }, {
        key: "_handleLienRoute",
        value: function _handleLienRoute(lien, output) {
            output.apply(this, [lien]);
        }

        /**
         * addPage
         * Adds a new page to be handled.
         *
         * @name addPage
         * @function
         * @param {String} url The page url.
         * @param {String} method The request methods to be handled (default: `"all"`).
         * @param {Function} output A function receiving the `lien` object as parameter. If can be a path serving a public file.
         */

    }, {
        key: "addPage",
        value: function addPage(url, method, output) {
            var _this4 = this;

            if (output === undefined) {
                output = method;
                method = "all";
            }

            var router = ~url.indexOf(":") ? this.router : this.beforeRequest;

            router[method](url, function (req, res, next) {

                var trans = _this4.getHooks("before", req.path, req.method.toLowerCase());

                if (trans) {
                    (function () {
                        var lien = new LienObj(req, res, next, _this4);
                        trans.start(lien, function (err, data) {
                            if (err) {
                                return lien.end(err);
                            }
                            _this4._handleLienRoute(lien, output);
                        });
                    })();
                } else {
                    _this4._handleRoute(req, res, output, [], next);
                }
            });
        }

        /**
         * errorPages
         * Handle the error pages.
         *
         * @name errorPages
         * @function
         * @param {Object} options An object containing the following fields:
         *
         *  - `notFound` (String|Function): The path to a custom 404 page or a function receiving the lien object as parameter. This can be used to serve custom 404 pages.
         *  - `serverError` (String|Function): The path to a custom 500 page or a function receiving the lien object as parameter. This can be used to serve custom 500 pages.
         */

    }, {
        key: "errorPages",
        value: function errorPages(options) {
            var _this5 = this;

            var sendResp = function sendResp(lien, msg, status) {
                if (lien.req.accepts("html")) {
                    return lien.end(msg, status);
                } else if (lien.req.accepts("json")) {
                    return lien.apiError(msg, status);
                }
                lien.end(msg, status, "txt");
            };
            options = ul.merge(options, {
                notFound: function notFound(lien) {
                    return sendResp(lien, "404 — Not found.", 404);
                },
                serverError: function serverError(lien) {
                    return sendResp(lien, "500 — Internal Server Error", 500);
                }
            });
            this.app.use(function (req, res, next) {
                return _this5._handleRoute(req, res, options.notFound, [], next);
            });
            this.app.use(function (err, req, res, next) {
                _this5.emit("serverError", err, req, res);
                if (_this5.options.logErrors) {
                    console.error(err.stack);
                }
                _this5._handleRoute(req, res, options.serverError, [err], next);
            });
        }

        /**
         * getHooks
         * Gets the transformer for a url.
         *
         * @name getHooks
         * @function
         * @param {String} type The hook type (`before` or `after`).
         * @param {String} url The url.
         * @param {String} method The method.
         * @returns {Transformer|null} The transformer (if it exists) or `null`.
         */

    }, {
        key: "getHooks",
        value: function getHooks(type, url, method) {
            var typ = this.transformers[type] = this.transformers[type] || {},
                all = setOrGet(typ, method, []),
                hooks = [];

            for (var i = 0, c; i < all.length; ++i) {
                c = all[i];
                if (c.re.test(url)) {
                    hooks.push(c.trans);
                }
            }

            if (hooks.length) {

                if (hooks.length === 1) {
                    return hooks[0];
                }

                return new Transformer({}, { autostart: false }).add(hooks, Transformer.PARALLEL);
            }

            return null;
        }

        /**
         * insertHook
         * Inserts a new hook.
         *
         * @name insertHook
         * @function
         * @param {String} type The hook type (`before` or `after`).
         * @param {String} url The url.
         * @param {String} method The method.
         * @param {Transformer} trans The transformer to insert.
         * @returns {Transformer} The inserted transformer.
         */

    }, {
        key: "insertHook",
        value: function insertHook(type, url, method, trans) {
            var all = setOrGet(this.transformers[type], method, []);

            all.push({
                re: pathToRegexp(url),
                trans: trans
            });

            return trans;
        }

        /**
         * hook
         * Adds a new hook.
         *
         * @name hook
         * @function
         * @param {String} where The hook type (`before` or `after`).
         * @param {String} url The route url.
         * @param {String} method The HTTP method.
         * @param {Function} cb The callback function.
         * @param {Number} transType The transformer type.
         */

    }, {
        key: "hook",
        value: function hook(where, url, method, cb, transType) {
            var _this6 = this;

            if (typeof method === "function") {
                cb = method;
                method = "all";
            }

            if (method === "all") {
                httpMethods.forEach(function (c) {
                    return _this6.hook(where, url, c, cb);
                });
                return this;
            }

            var trans = {};
            switch (where) {
                case "before":
                case "after":
                    trans = this.getHooks(where, url, method) || this.insertHook(where, url, method, new Transformer({}, { autostart: false }));
                    break;
                default:
                    throw new Error("The hook type should be either before or after.");
                    break;
            }

            trans.add(cb, transType);
            return this;
        }
    }]);

    return Lien;
}(EventEmitter);